//Решить задачу о раскраске графа

//способ раскрасить вершины Graph таким образом, чтобы никакие две соседние вершины не имели одинаковый цвет

#include <iostream>
#include <vector>
#include <unordered_map>
#include <set>

// Структура данных для хранения ребра Graph
struct Edge 
{
    int src, dest;
};

class Graph
{
public:
    // вектор векторов для представления списка смежности
    std::vector<std::vector<int>> adjList;

    // Конструктор
    Graph(std::vector<Edge> const& edges, int n)
    {
        // изменить размер вектора, чтобы он содержал `n` элементов типа `vector<int>`
        adjList.resize(n);

        // добавляем ребра в неориентированный graph
        for (Edge edge : edges)
        {
            int src = edge.src;
            int dest = edge.dest;

            adjList[src].push_back(dest);
            adjList[dest].push_back(src);
        }
    }
};

// Добавляем больше цветов для graphs с большим количеством вершин
std::string color[] =
{
    "", "Синий", "Зелёный", "Красный", "Жёлтый", "Оранжевый", "Розовый",
    "Чёрный", "Серый", "Белый", "Фиолетовый", "Пурпурный"
};

// Функция для присвоения цвета вершинам Graph
void colorGraph(Graph const& graph, int n)
{
    // отслеживаем цвет, присвоенный каждой вершине
    std::unordered_map<int, int> result;

    // назначаем цвет вершине одну за другой
    for (int u = 0; u < n; u++)
    {
        // устанавливаем для хранения цвета смежных вершин `u`
        std::set<int> assigned;

        // проверяем цвета смежных вершин `u` и сохраняем их в наборе
        for (int i : graph.adjList[u])
        {
            if (result[i]) 
            {
                assigned.insert(result[i]);
            }
        }

        // проверяем первый свободный цвет
        int color = 1;
        for (auto& c : assigned)
        {
            if (color != c) 
            {
                break;
            }
            color++;
        }

        // назначаем вершине `u` первый доступный цвет
        result[u] = color;
    }

    for (int v = 0; v < n; v++)
    {
        std::cout << "Цвет, присвоенный вершине " << v << " = "
            << color[result[v]] << std::endl;
    }
}

// Жадная раскраска Graph
int main()
{
    setlocale(LC_ALL, "Russian_Russia.1251");
    // vector ребер Graph согласно схеме выше
    std::vector<Edge> edges = 
    {
        {0, 1}, {0, 4}, {0, 5}, {4, 5}, {1, 4}, {1, 3}, {2, 3}, {2, 4}
    };

    // общее количество узлов в Graph (от 0 до 5)
    int n = 6;

    // строим graph из заданных ребер
    Graph graph(edges, n);

    // цветной Graph с использованием жадного алгоритма
    colorGraph(graph, n);

    return 0;
}


/*
----- Теорема Брукса ----- 
утверждает, что связный graph можно раскрасить только x цвета, 
где x максимальная степень любой вершины в Graph, 
за исключением полных графов и графов, содержащих цикл нечетной длины, что требует x+1 цвета.


Жадная раскраска рассматривает вершины Graph последовательно и присваивает каждой вершине свой первый доступный цвет, 
т. е. вершины рассматриваются в определенном порядке v1, v2, … vn, а также vi и назначен наименьший доступный цвет, 
который не используется ни одним из vi соседи.

Жадная раскраска не всегда использует минимально возможное количество цветов для раскраски Graph. 
Для Graph максимальной степени x, жадная раскраска будет использовать не более x+1 цвет. 
Жадная раскраска может быть сколь угодно плохой; например, следующий коронный graph (полный двудольный graph), 
имеющий n вершины могут быть двухцветными, но жадная раскраска приводит к n/2 цвета.

*/